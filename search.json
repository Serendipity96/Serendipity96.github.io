[{"title":"Java 分代垃圾回收","url":"/2022/06/22/java-gc/","content":"什么是 Java 分代垃圾回收？\n分代是指：Java 根据对象的生命周期时长，将对象分为年轻代、年老代和持久代，根据不同代采用不同策略垃圾回收。\n在 JVM 中，堆内存划分为 Eden、Survivor 和 Tenured&#x2F;Old 区，Eden、Survivor 区存储年轻代对象，Tenured&#x2F;Old 区存储年老代的对象。\n垃圾回收主要回收的是年轻代和年老代的对象空间。\n年轻代所有新创建的对象都会进入 Eden 区，当 Eden 区存满了（达到一定比例）的时候，就会启动垃圾回收，回收无用对象。经过垃圾回收后依然有用的对象，会进入 Survivor 区。\n年老代在年轻代中经历了 N（默认 15）次垃圾回收后依旧存在的对象，就会被放入到 Tenured&#x2F;Old 区，成为年老代。年老代中的对象是生命周期较长的对象。\n持久代持久代一般用于存放静态文件，如：Java 类、方法。持久代对垃圾回收没什么影响。\n\nMinor GC清理年轻代区域内存，Eden 满了就会触发 Minor GC。\nMajor GC清理年老代区域内存。\nFull GC清理年轻代和年老代区域内存，成本比较高，可能会对系统性能产生影响。\n可能导致 Full GC 的情况\n年老代内存打满\n持久代内存打满\nSystem.gc() 被显式调用（注意：是建议 Java 启动 GC，但是否启动依据 Java 内部决定）\n上一次 GC 之后堆内存各区域分配策略动态变化\n\n","categories":["Java","学习笔记"],"tags":["Java","学习笔记"]},{"title":"Firefox Manifest V3：进展及下一步计划","url":"/2022/05/31/firefox-mv3/","content":"译者总结2022-05-18，Mozilla 官方博客发布了关于扩展（WebExtension）MV3 的进展和计划，以及和 Chrome MV3 不同的地方。值得注意的进展：\n\n在 W3C 下成立了一个社区小组来推进跨浏览器 WebExtensions (WECG)\nbackground script 可重新启动\ncontent scripts 不支持未经允许的跨域请求\n兼容 blocking WebRequest 和 declarativeNetRequest\nEvent Pages 方案\n\n博客原文链接：Manifest V3 in Firefox: Recap &amp; Next Steps\n如需转载译文，请注明译者：Serendipity96\n以下是博客译文\n距离上次讨论 Manifest V3 （Manifest V3 update）已经过去了一年。这期间最重要的变化是在 W3C 下成立了一个社区小组来推进跨浏览器 WebExtensions (WECG)。\n在之前的文章中，Firefox 宣布支持 MV3，在 background pages 中使用 Service Workers。（译者注： MV3 前，background 中使用的是html 和 js ）直接使用 Service Workers 会使一部分扩展有问题，所以一直在调整方案。其中在 WECG 中提出的 Event Pages 方案受到了社区的欢迎，并得到了 Safari 浏览器的支持。\n我们将启动开发者预览计划来收集 MV3 的反馈。接下来的篇幅会介绍 Firefox MV3 的改进之处，然后谈谈与 Chrome MV3 不同的地方。\n为什么使用 MV32015 年我们使用 WebExtensions model 时，就决定要支持跨浏览器。我们坚信，一个扩展能运行在多个浏览器上，对用户来说是最好的服务。到 2017 年底，不仅支持跨浏览器，而且使用了 WebExtensions model。现在许多扩展只需要微小的改动就能用运行在大多数浏览器上，而且到现在为止依然使用的是 WebExtensions model。\n2018 年，Chrome 发布了 Manifest V3，随后微软采用 Chromium 作为新 Edge 浏览器的内核。这意味着，未来凭借 Chromium 内核浏览器在市场上的占比，对 MV3 的支持将成为浏览器扩展的标准。我们相信，在 WECG 的背景下与其他浏览器供应商合作，是平衡用户和开发者需求、建立健康生态的最佳途径。对 Mozilla 来说，这是一项长期的工作。\n为什么 MV3 对改进 WebExtension 很重要Manifest V3 是 WebExtensions 的一次技术迭代，这提供了改进 WebExtensions 的机会，支持向后兼容。由于 MV2 架构上的限制，有些问题难以解决，现在可以通过 MV3 来解决这些问题。\n扩展架构中一个核心的部分是 background page，从设计上来说它会一直在运行在浏览器上。但由于内存或平台限制（例如在 Android 上），并不能保证一直运行的状态，不可避免 background page 和扩展本身会被终止运行。MV3 采用了新型架构：background script 可重新启动。为了支持这一特性，我们重新设计了现有 API，并引入了新的 API，使扩展能够声明浏览器应该如何运行，而无需 background script 。\n扩展的另一个核心是 content scripts，用于与网页交互。我们正阻止不安全的编码行为，并提供更安全的替代方案来提高扩展的安全性。比如：字符串类的 API 已从扩展 API 中删除。此外，为了提升不同 origin 的数据隔离能力，除非目标网站同意跨域（CORS），否则 content scripts 不支持跨域请求。\n网站访问的用户控制扩展程序经常需要访问网站上的用户数据，虽然这能让扩展的功能更强大、满足用户的需求，但这也导致了扩展滥用用户隐私。\n从 MV3 开始，我们把来自扩展程序的请求作为可选项，并为用户提供透明可选的控制，让用户更容易地管理扩展程序可以访问的网站数据。\n同时，我们鼓励扩展使用非永久访问所有网站的模式，如小范围或暂时授权模式。我们正继续探索如何以最优的方式处理要拦截的网站，保护用户的安全（如隐私和安全扩展）。\nFirefox 做了哪些修改网络请求（WebRequest）Chrome MV3 中最有争议的变化之一是禁止使用 blocking WebRequest，Chrome MV3 提供了更灵活的 declarativeNetRequest，这对管理高级隐私和内容屏蔽非常重要。但定义一个范围更小的 API（declarativeNetRequest）替代 blocking WebRequest，会限制一些扩展的能力。\nMozilla MV3 会继续支持 blocking WebRequest。为了最大限度地兼容其他浏览器，也会支持 declarativeNetRequest。Mozilla 将继续与内容拦截器、blocking WebRequest API 主要的消费者合作，确定最合适的方案。内容拦截是扩展程序最重要的功能之一，我们致力于确保 Firefox 用户能够使用到最好的隐私工具。\nEvent PagesChrome MV3 引入了 Background Service Worker 作为持久化运行 Background Page 的方案。Mozilla 也支持在 Firefox 扩展中使用 Service Workers，这不仅是出于兼容性的考虑，还因为 Service Workers 是一个有生命周期事件驱动的环境，它已经是支持跨浏览器 Web 平台的一部分了。\n但我们发现 Service Workers 不支持某些重要的使用场景，特别是 DOM 相关的功能和 API。此外，普通的 Web 开发者并不熟悉 worker 的环境，我们的开发者社区指出，重写扩展对于现有扩展的开发者来说可能有些困难。\nFirefox 决定在 MV3 中支持 Event Pages，我们的开发者预览版不包括 Service Workers（我们还在开发，未来的版本将支持 Service Workers）。这将帮助开发者更容易地迁移现有扩展的 background pages 支持 MV3，同时保留 MV2 中所有 DOM 相关的功能。在即将发布的版本中， MV2 会支持 Event Pages，这有利于 MV2 扩展迁移。\nFirefox 下一步计划在启动 Manifest V3 开发者预览计划时，希望广大开发者能来测试 MV3 的实现，帮我们找出 bug 或不兼容之处，预计在 2022 年底前推出 MV3 支持版。随着这项工作接近完成，我们将公布更多关于时间节点和迁移的细节。\n有关 Manifest V3 开发者预览版的更多信息，请查看迁移指南。如果您对 Manifest V3 有任何疑问或反馈，我们很乐意在 Firefox Add-ons Discourse 听到您的意见。\n","categories":["extension","翻译"],"tags":["extension","翻译"]},{"title":"V8 是如何执行 JavaScript 代码的呢？","url":"/2022/04/10/google-v8/","content":"V8 是如何执行 JavaScript 代码的呢V8 是 JavaScript 虚拟机的一种。计算机执行高级语言有两种基本方式：解释执行和编译执行。解释执行和编译执行各有优缺点，解释执行启动速度快，但是执行时速度慢；编译执行启动速度慢，但是执行速度快。V8 采用的是混合编译执行和解释执行技术（即 JIT，Just In Time）。\nV8 是如何判断什么时候需要解释执行，什么时候需要编译执行的呢V8 中有一个监控器，在解释执行过程中，如果某段代码的字节码被重复多次执行，监控器会将这段代码标记为热点代码。V8 会将这段代码的字节码传给优化编译器，编译成二进制代码，此时这段代码的执行效率会大幅提升。\n但 JavaScript 是非常灵活的动态语言，对象结构和属性可以在运行时任意修改，经过优化编译过的代码只能针对某种固定的结构，一旦在执行过程中对象结构被动态修改，二进制代码就是无效代码了，此时优化编译器进行反优化操作，经过反优化的代码下次执行时会回退到解释器解释执行。\nV8 执行一段 JavaScript 代码的主要流程\n初始化基础环境\n解析源码生成 AST 和作用域\n依据 AST 和作用域生产字节码\n解释执行字节码\n监听热点代码\n优化热点代码为二进制机器代码\n反优化生产的二进制机器代码\n\n\n除了 JavaScript， 像 Python、PHP、Lua 都采用了 JIT 技术。\n知乎上有一个关于 Chrome V8 的分析专栏，内容不错，且持续更新：https://www.zhihu.com/column/v8core\n","categories":["V8","学习笔记"],"tags":["学习笔记","V8"]},{"title":"不写代码，如何为开源项目做贡献？","url":"/2021/09/13/contribute-opensource-without-code/","content":"笔者为开源项目贡献过几个 PR，提交过几个 issue，直到现在还清晰记得几年前第一个 PR 被 merge 时的兴奋，体验到了参与开源的乐趣。但是只停留在了 contributor 阶段，没有下文了，因为笔者后来不做研发了，认为不熟悉代码、不能修 bug 就没有贡献的机会了。\n这里是有一个误区的，并非只有贡献代码、修复 bug 才是为项目做贡献。成为贡献者只能通过贡献代码的方式吗？如果我不会写代码，并非开发者，怎样才能成为一个开源项目的贡献者，甚至晋升为 committer 呢？\n笔者梳理之后，发现有非常多的方式，在这里分享给大家，无论是不是开发者，都可以实践。（笔者也在实践的路上）\n非代码方式写文章写文章是一个很容易被忽略的方式，我们可以通过文章来宣传、布道某个技术。比如撰写某个项目的上手指南、踩坑记录、架构设计分析、实现原理等等。\n如果开始写文章比较困难，可以先从翻译做起，无论是中译英还是英译中，只要是对这个项目有意义的内容，都是在为它做贡献。\n亦或是你观看了别人的技术实战分享，把别人的分享整理成文字版，分享到社区中，帮助更多人了解项目。\n笔者还注意到，有些贡献者把文章整理成一本开发小册、或者一本专业书籍，系统地向其他人介绍某项技术。\n制作视频制作视频也是一个不错的方式。我们可以把文字的方式转换成视频，用视频的方式介绍某个开源项目，录制上手指南、踩坑记录、架构设计分析、实现原理等等。笔者也看到了很多项目采用视频的方式介绍，视频可能是动画的形式，也可能是真人讲解，无论哪一种，视频在呈现上会比文字更生动有趣一些。\n不过前期剪辑视频对于新手来说工作量可能比较大。\n大会分享如果你不害羞、喜欢外分享，那么去技术大会上分享、布道开源项目也是一个很不错的选择。这对了解项目的新手可能有难度，假以时日，当我们从小白进阶成熟悉者时，去分享就比较容易达成了。分享可以锻炼自己的表达能力、逻辑思维能力，还可以锻炼自己的胆量~（也可能收获到橄榄枝）\n完善文档大多数开发者并不喜欢写文档，但是文档是其他人了解项目、上手项目的重要途径。笔者曾经的开发经历中，如果遇到一份清晰详细的文档，感觉是非常幸运的事情，上手项目会快很多。文档内容不限于启动说明，如果有架构设计、原理介绍再好不过了。\n我们可以为感兴趣的开源项目提交文档，甚至是修复文档，比如：\n\n代码更新，文档没有同步更新\n修复错误的下载链接、文档链接\n优化文档，修改文档描述，使其更易理解\n提交架构设计、原理介绍文档\n\n建设本地社区，组织&#x2F;参与活动如果你对一个项目很感兴趣，参与到本地的社区中，和志同道合的人交流、组织当地的活动，为项目发展做贡献。\n如果没有本地社区，你可以作为发起人建设本地社区。笔者了解到 Apache 软件基金会鼓励大家建设 Local Community，比如 ALC Beijing。像其他的技术社区，如：KubeSphere、云原生社区都在积极发展本地社区。\n积极参与社区讨论活跃在 Apache mail listApache 文化鼓励大家通过邮件列表的形式讨论问题、做决策，所有的事项都要有所记录。每一个 Apache 项目都有自己专属的邮件列表，如果对项目有什么想法，社区非常鼓励大家到邮件列表讨论。\n我们可以：\n\n为项目发版投票\n回复其他人发起的讨论，表达自己的观点\n发起一次讨论\n\n为什么是邮件列表？\n邮件列表给我的感觉很古老，笔者去了解了 Apache 软件基金会发展历史，最初基金会的创始人是通过邮件列表的方式讨论问题，难道是古老文化的保留？\n虽然互联网发展迅速，但是世界上仍有接收图片困难、使用其他软件的困难，尽管是我们熟知的 wechat、Twitter 使用者也没有覆盖全球，但是使用邮件能够以最小门槛的方式与他人建立联系，保障全世界各地的人都能参加到社区讨论中，这就是 Apache 软件基金会保留邮件列表方式的初衷。\n活跃在 GithubGithub 是开发者最常逛的网站了，大多数的开源项目都托管在 Github 上。我可以在感兴趣的项目下\n\n提 issue 说出我的想法，项目的改进方向\n提交一个 bug report\nreview 其他小伙伴提交的 pr\n\n这些都是为开源项目做贡献的方式。\nApache mail list vs Github有 Github 为什么还要使用邮件列表？代码托管在 Github ，看起来社区的协作工作好像都是在 Github 上完成的呀？\n在邮件列表里讨论问题，如果大家没有提出反对意见，可以默许为大家通过提议。如果有反对意见，大家会充分讨论，最终达成一致或搁置。\n使用邮件列表的方式讨论，也是对 Apache 文化的认同。遵循 Apache 规则的项目，邮件列表是是社区的首要阵地，Github 是一个方便的协同工具。\n代码方式贡献功能、修复 bug当然了，开源项目肯定是离不开代码的。如果开源项目的技术栈你很熟悉，很快就能上手贡献代码，和社区小伙伴们一起完善相关功能、修复 bug，持续贡献，成为项目 contributor，进一步提名成为 committer、PMC 是很容易的事情。大多数的贡献者都是通过提交代码的方式成为 committer 的，但是作为像笔者这样不熟悉代码的小伙伴，这一条就不适合了。\n这里需要注意一点，committer 是对贡献者过往贡献的肯定，不会因为未来不再贡献而去除 committer 身份，也不会因为是 committer 而有更大的权利，社区中人人平等。\n总结本文介绍了很多成为开源项贡献的途径，如果你有很感兴趣的开源项目却不熟悉代码，又想参与到开源社区中，写文章、做视频、对外分享、建立本地社区、积极参与社区讨论都是很不错方式哦，欢迎实践。\n","categories":["开源"],"tags":["开源"]},{"title":"还傻傻分不清 module.exports 和 export default  吗？","url":"/2019/09/29/modules/","content":"前言在使用 vue、react、node 的时候，常常会看到 module.exports，export default，require，import 等字段，因为我对这些字段的概念非常模糊，所以导致我在写代码的时候，在 node 项目里混用了 export default，在 vue 的项目里写 module.exports。\n那么今天就来梳理一下有关模块化的知识。\nESM 的模块语法ESM（ECMA Script Modules）模块主要由两个命令构成：export 和 import。\n暴露模块：export default &#123;&#125; , export &#123;&#125; , export function()&#123;&#125;引入模块：import &#123;xxx&#125; from &#x27;path&#x27;\n\n注意import 的大括号里面指定要从其他模块导入的变量名，如果 export 命令没有写 default，那么 import 大括号里面的变量名，必须与 export 导出的名称相同。\n// test.jsexport &#123;foo&#125;// main.jsimport &#123; foo &#125; from &#x27;./test.js&#x27;// 如果想为输入的变量重新取一个名字，要使用as关键字，将输入的变量重命名import &#123; foo as bar &#125; from &#x27;./test.js&#x27;;\n\ndefault 的作用default 为模块指定默认输出，这样在引入时就不必关心模块输出的名字。\n// test.jsfunction foo() &#123;&#125;;export default &#123;foo&#125;// main.jsimport bar from &#x27;./test.js&#x27;\n\n本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。\n有关 ESM 模块的语法，可以阅读 阮一峰 的文章，这里不详细写出所有写法。\n加载机制我们在使用 import 和 export 的时候，常常看到的是在顶层作用域使用 export 和 import，不会在块级作用域内看到 import 和 export，这是为什么呢？\n因为 ESM 模块的设计思想是尽量静态化，编译时就能确定模块的依赖关系，以及输入和输出的变量，如果处于块级作用域内，就没法做静态优化了，违背了 ES6 模块的设计初衷。\n但是我明明在 vue router 的使用中看到了这样的写法：\nconst Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#x27;./Foo.vue&#x27;)\n此时 import 的写法和常规写法不一样，是 import(), 并且确实出现在了块级作用域内。\nESM 有一个提案，建议引入 import()函数，完成动态加载。现在支持动态加载的比如：vue router、webpack。\nvue router 动态加载vue router 的 路由懒加载\nwebpack 动态导入webpack 动态导入\nNode.js 的模块语法暴露模块：module.exports = value 或 exports.xxx = value引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径\n\nNode 的模块输出和引入的方式与 ESM 不同，Node 采用的是 CommonJS 模块规范。\nCommonJS 规范规定，在每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（module.exports）是对外的接口。\n为什么采用 CommonJS 规范呢Node.js 主要用于服务端项目，CommonJS 规范也主要用于服务端编程，所以 Node 的模块设计采用 CommonJS 规范很合适。\n模块化发展的历史为什么会有 AMD CMD 规范服务端模块的加载是同步的，但是浏览器资源是异步加载，同步意味着阻塞，在没有 ESM 模块之前，浏览器想做模块化怎么办呢？\nAMD CMD 解决方案。\n实际上 AMD (Asynchronous Module Definition) 是 RequireJS 在推广过程中对模块定义规范化的产出。\nCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出。\nSeaJS 和 requireJS 解决的都是模块化问题,只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。\n以下例子引用自 WEB 前端模块化都有什么\nAMD\n// hello.jsdefine(function() &#123;    console.log(&#x27;hello init&#x27;);    return &#123;        getMessage: function() &#123;            return &#x27;hello&#x27;;        &#125;    &#125;;&#125;);// world.jsdefine(function() &#123;    console.log(&#x27;world init&#x27;);&#125;);// maindefine([&#x27;./hello.js&#x27;, &#x27;./world.js&#x27;], function(hello) &#123;    return &#123;        sayHello: function() &#123;            console.log(hello.getMessage());        &#125;    &#125;;&#125;);// 输出// hello init// world init\n\nCMD\n// hello.jsdefine(function(require, exports) &#123;    console.log(&#x27;hello init&#x27;);    exports.getMessage = function() &#123;        return &#x27;hello&#x27;;    &#125;;&#125;);// world.jsdefine(function(require, exports) &#123;    console.log(&#x27;world init&#x27;);    exports.getMessage = function() &#123;        return &#x27;world&#x27;;    &#125;;&#125;);// maindefine(function(require) &#123;    var message;    if (true) &#123;        message = require(&#x27;./hello&#x27;).getMessage();    &#125; else &#123;        message = require(&#x27;./world&#x27;).getMessage();    &#125;&#125;);// 输出// hello init\n\nCMD 的输出结果中，没有打印”world init”, 并是不 world.js 文件没有加载。\nAMD CMD 规范加载机制AMD 与 CMD 都是在页面初始化时加载完成所有模块，区别是 CMD 就近依赖, 是当模块被 require 时才会触发执行, AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。\n同样都是异步加载模块，AMD 在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入 require 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。\nCMD 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。\n这也是很多人说 AMD 用户体验好，因为没有延迟，依赖模块提前执行了，CMD 性能好，因为只有用户需要的时候才执行。\nUMD 规范解决了什么问题AMD &amp; CMD，CommonJS 规范是两类规范，AMD &amp; CMD 用于浏览器模块化，CommonJS  用于服务端模块化，但是大家的期望有一个统一的规范来支持这两种规范。于是，UMD 规范诞生了。\nUMD (Universal Module Definition)，它可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD &#x2F; AMD 的项目中运行，同一个 JavaScript 包在浏览器 &#x2F; 服务端只需要遵守同一个写法就可以了。\nUMD 没有自己专有的规范，是集结了 CommonJs、CMD、AMD 的规范于一身，UMD 先判断是否支持 Node 模块格式（exports 是否存在），存在则使用 Node 模块格式，再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块，如果前两个都不存在，则将模块公开到全局（window 或 global）。\n更早之前立即执行函数实现模块化（IIFE，Immediately-Invoked Function Expression）\n使用立即执行函数，表达式中的变量不能从外部访问。现在项目中已经看不到这样的写法了。\n例如：\n(function()&#123;    var count = 0;    return count;&#125;)();\n\n\n\n模块化方案总结\n\n\n\nESM\nCommonJS\nAMD\nCMD\nUMD\n\n\n\n加载机制\n编译时\n运行时\n提前预加载\n编译时 &amp; 运行时按需加载\n-\n\n\n同步&#x2F;异步\n异步\n同步\n异步\n异步，有延迟执行的情况\n-\n\n\n适用场合\n浏览器、服务端\n服务端\n浏览器\n浏览器\n浏览器、服务端\n\n\n是否常见\n☆☆☆\n☆☆☆\n☆\n☆\n☆\n\n\nESM 在语言标准的层面上，成为浏览器和服务端通用的模块解决方案。\n工具时代webpack 在定义模块上，支持上面提到的所有模块声明方式，只需要在 webpack 的 output 中添加 libraryTarget: ‘commonjs&#x2F;amd&#x2F;umd’即可。\n模块化的好处\n避免命名冲突，每个模块内的变量仅对自己可见，外部获取依赖模块输出\n按需加载\n解耦、复用、高可维护性\n\n参考资料ECMAScript 6 入门\n前端模块化详解(完整版)\nAMD 与 CMD 区别\nSeaJS 和 RequireJS 的差异\n","categories":["JavaScript"],"tags":["模块化"]},{"title":"【译】来试试这个真正的 JavaScript 调试器吧！","url":"/2018/02/10/js-debugger/","content":"\n\n原文地址：Debugging JavaScript With A Real Debugger You Did Not Know You Already Have\n原文作者：Dustin Driver\n译文出自：掘金翻译计划\n本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO/javascript-firefox-debugger.md\n译者：Serendipity96\n校对者：ZhiyuanSun，noahziheng\n\n\nconsole.log 可以告诉你很多关于应用程序的信息，但它不能真正调试你的代码。因此，你需要一个完整的 JavaScript 调试器。新的 Firefox JavaScript 调试器能够帮你写快速且无缺陷的代码。下面来介绍它的用法。\n在这个例子中，我们将用 Debugger 打开一个非常简单的应用程序。此应用程序是基于一个基础的 JavaScript 开源框架开发的。在最新版本的Firefox Developer Edition中打开此程序，Mac 系统按 Option + Cmd + S 或者 Windows 系统按 Shift + Ctrl + S 启动 debugger.html。调试器共分为三个窗格：源列表窗格，源代码窗格和工具窗格。\n\n大图预览\n工具窗格进一步分为工具栏，监视表达式，断点，调用堆栈和范围。\n\n大图预览\n停止使用 console.log使用 console.log 来调试代码是很诱人的。你只需在代码中添加一句 console.log ，然后执行即可找到变量的值，对不对？这确实可以奏效，它可能是麻烦且费时的。在这个例子中，我们将使用 debugger.html 单步执行这个待办事项应用的代码来查找变量的值。\n我们在 debugger.html 的一行代码中添加一个断点，来深入了解待办事项应用程序。断点告诉调试器在这一行上暂停，这样你可以点击代码来看看发生了什么。在这个例子中，我们在 app.js 文件的第 13 行添加一个断点。\n\n大图预览\n现在添加一个任务到列表中。代码将会暂停到 addTodo 函数，我们可以深入代码来查看输入的值等。将鼠标悬停在变量上可以看到更多信息。你可以看到锚点和子程序等各种信息：\n\n大图预览\n你也可以进入 Scopes 面板获取相同的信息。\n现在脚本已经暂停，我们可以使用工具栏来逐步调试。开始&#x2F;暂停按钮正如工具栏上所显示的含义，” Step Over “ 跨越当前代码行，” Step In “ 步入函数调用，” Step Out “ 运行脚本，直到当前函数退出。\n\n大图预览\n我们也可以使用监视表达式来跟踪变量的值。只需在监视表达式字段中输入一个表达式，调试器将在你逐步执行代码时进行跟踪。在上面的例子中，你可以添加表达式 “ title “和 “ to-do “，当它们被调用时，调试器会显示它们的值。以下情况特别有用：\n\n你正单步执行并想看变量值的变化；\n你正多次调试同样的东西，并希望看到相同的变量值；\n你想弄清楚为什么那个该死的按钮不起作用。\n\n你也可以用 debugger.html 去调试 React &#x2F; Redux 应用程序。以下是使用步骤：\n\n跳转到你要调试的组件。\n参阅左侧的组件大纲（类中的函数）。\n添加断点到相关的函数中。\n暂停并查看组件 props 和 state。\n调用堆栈是已经被简化的，这便于你查看应用程序代码和框架的交集。\n\n最后，debugger.html 让你看到可能引起错误的混淆或压缩的代码，这在处理像 React &#x2F; Redux 这样的通用框架时特别有用。调试器知道你已暂停的组件，并显示简化的堆栈调用，组件大纲和属性。以下是开发人员 Amit Zur 在 JS Kongress 上描述他是如何使用 Firefox 调试器调试代码的：\n\n\n如果你在新的 debugger.html 中对深入代码走查感兴趣，请转到Mozilla Developer Playground。我们构建了一个系列教程，帮助开发人员学习如何有效地使用该工具来调试代码。\n开源的开发工具debugger.html project大约于两年前推出，同时对所有 Firefox DevTools 进行了全面改进。我们希望使用现代网络技术重建 DevTools，并对全世界的开发者开放。当一项技术开放的时候，能够自由扩展到我们 Mozilla 小团队所能想象的范围之外的任何地方。\nJavaScript 对于任何高级 Web 应用程序都是必不可少的，所以强大的调试器是工具集的关键部分。我们希望构建一些快速，易于使用且适应性强 —— 能够调试未来可能出现的任何新 JavaScript 框架的产品。我们决定使用流行的网络技术，因为我们想与社区紧密合作。这种方法也将改善调试器本身 —— 如果我们采用了 WebPack 并开始在内部使用构建工具和 Source Map，我们希望改进 Source Map 生成和热加载。\ndebugger.html 是用 React，Redux 和 Babel 构建的。React 组件轻量，可测试又易于设计。我们使用 React Storybook 进行快速的 UI 原型设计和记录共享组件。我们的组件使用 Jest 和 Enzyme 进行测试，这使得在 UI 上迭代更容易。这让使用各种 JavaScript 框架（如 React ）更容易。Babel 前端能让我们做一些像显示左侧边栏中 Component 类和它功能的事情。我们也可以做一些很酷的事情，例如把断点固定到函数中，当你改变你的代码时，它们不会移动。\nRedux Action 对于 UI 来说是一个简单的 API，但它也可以很容易地构建一个独立的 CLI JS 调试器。Redux Store 有查询当前调试状态的选择器。我们的 Reduce 单元测试激发了 Redux Action 并模拟浏览器响应。我们的集成测试使用调试器 Redux Action 来驱动浏览器。功能架构本身被设计为可测试的。\n我们每一步都依靠 Mozilla 开发人员社区。该项目在 GitHub  上发布，我们的团队联系世界各地的开发人员向他们寻求帮助。当我们开始时，自动化测试是社区发展的重要组成部分，测试可以预防性能退化，也能很好地记录容易遗漏的行为。这就是为什么我们采取的第一步是为 Redux Store 添加 Redux Action 和 Flow 类型的单元测试。事实上，社区确保我们的 Flow 和 Jest 覆盖率有助于确保每个文件都被打印和测试。\n作为开发者，我们相信工具越强，参与的人越多。我们的核心团队一直很小（2 人），但我们平均每周有 15 个贡献者。社区带来了多样的视角，帮助我们预测挑战并创造了我们从未想到的功能。我们现在整理了 24 个不同库的调用堆栈，其中有许多我们从未听说过。我们还在源代码树中显示 WebPack 和 Angular 映射。\n我们计划将所有的 Firefox DevTools 移到 GitHub 上，以便更广泛的受众使用和改进它们。我们很乐意为您做出贡献。转到 debugger.html 的 GitHub 项目页面。我们已经创建了一个关于如何在自己的机器上运行调试器的完整的指令列表，在列表里你可以修改使它做任何你想做的事。使用它来调试任何 JavaScript 代码 —— 浏览器，终端，服务器，手机，机器人。如果您有改进的方法，请通过 GitHub 告诉我们。\n您可以在这里下载最新版本的 Firefox（和 DevTools）。\n\n\n掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。\n\n","categories":["翻译"],"tags":["翻译"]}]